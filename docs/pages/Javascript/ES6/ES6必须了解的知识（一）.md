# ES6必须了解的知识（一）

:::
  随着前端的快速发展，javascript的语言已无法满足日常开发的需求,因此需要增加一些新的特性来适应前端开发的发展。
:::

## Reflect

### 概念

Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。
与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new 运算符对其进行调用，或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的（就像 Math 对象）。

### 产生的原因

1. 早期的ECMA规范中没有考虑到这么多，不知道如何设计对对象的操作更加的规范，所以将操作对象的API放在了Object上。
2. Object是一个构造函数，将这些API放到函数本身就不是很合理（虽然函数也是对象）。
3. 还包含了一些 in ，delete操作符，使JavaScript看起来有点的奇怪。

### 使用


### 场景

### 相比于Object的优势
Reflect 对象提供了一种更加明确和一致的方式来操作对象属性，与直接使用 Object 方法相比，它具有以下几个好处：

1. 一致性：
    Reflect 提供了一系列与 Object 方法对应的静态函数，这些函数的行为与 Object 的方法类似，但提供了一致的接口。这意味着你可以使用统一的API来处理对象属性，而不是记住 Object 下不同方法的差异。

2. 无副作用：
    Reflect 方法不会导致任何副作用，它们要么返回一个值，要么返回 undefined。这与 Object 方法不同，后者可能会抛出异常。

3. 错误处理：
    使用 Reflect 方法时，如果操作失败，它们通常返回 undefined 而不是抛出异常。这使得你可以更容易地进行错误检查和处理，而不是使用 try...catch 块。

4. 与 Proxy 的兼容性：
    Reflect 的方法与 Proxy 对象的方法一一对应。当你使用 Proxy 来捕获和自定义对象属性的访问时，Reflect 允许你以一种与操作原始对象相同的方式操作代理对象。

5. 更清晰的语义：
    Reflect 的方法命名通常更加直观，例如 Reflect.has(target, propertyKey) 与 "propertyKey" in target 有相同的效果，但语义更清晰。

6. 避免使用 eval：
    Reflect 提供了一些方法，如 Reflect.get 和 Reflect.set，它们可以替代 eval 在某些情况下的使用，因为 eval 会执行任意代码，可能导致安全问题。

7. 元编程：
    Reflect 使得进行元编程变得更加容易，即编写能够操作或生成其他程序代码的代码。

8. 更好的调试：
    由于 Reflect 方法的一致性和返回值，调试时可以更容易地追踪和理解代码的行为。

9. ES6标准：
    Reflect 是ES6标准的一部分，它的引入使得JavaScript的元操作更加完整和一致。

10. 避免直接操作内置对象：
    使用 Reflect 可以避免直接操作或修改内置的 Object 原型，这有助于保持框架和库的稳定性。


## Proxy

### 概念

### 产生的原因

### 使用

### 场景
